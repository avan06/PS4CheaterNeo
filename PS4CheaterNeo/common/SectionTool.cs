using System;
using System.Collections.Generic;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text.RegularExpressions;
using System.Threading;

namespace PS4CheaterNeo
{
    /// <summary>
    /// [About SID]
    /// To process memory addresses, the program needs to use SectionID to obtain the corresponding Section.
    /// 
    /// The original PS4_Cheater's rule for establishing SectionID is to sort Sections from low to high address, and obtain the count value as SectionsID.
    /// for example, if the SectionID is 100, the Section in the 100th position will be read.
    /// 
    /// What is the problem? When the number of Sections is low, the order will not be wrong,
    /// but if the number of Sections is from one hundred to more than one thousand, it is easy to obtain the wrong Section,
    /// because the game is started at different times, the value of Section often changes.
    /// 
    ///
    /// This program attempts to create a SectionID that can correctly correspond to a Section at different times,
    /// SectionID is abbreviated as SID below, and its encoding rules are as follows(rules established before 0.9.5.5-beta):
    /// 
    /// 1. The 1st code is idx used to count multiple Sections generated by the same MemoryEntry
    /// 2. The 3rd to 6th code is sIdx will continue to count until the Prot value changes and will be reset
    /// 3. The 7th to 8th code is ProtCnt will count when the Prot value changes
    /// 4. The 9th code is the TypeCode when the Section has a name it is 1, otherwise it is 2
    /// 
    /// 
    /// After a while, I found that the above rules are still not enough,
    /// and the new encoding rules from the 0.9.5.5-beta are as follows:
    /// 
    /// 1. The 1st code is idx used to count multiple Sections generated by the same MemoryEntry
    /// 2. The 3rd to 5th code is sIdx will continue to count until the HighBits or TypeCode or Prot changes, it will be reset
    /// 3. The 6th code is ProtCnt which counts when the Prot value changes and resets when the TypeCode changes
    /// 4. The 7th code is the TypeCode when the Section has a name it is 1, otherwise it is 2
    /// 5. The 8th to 10th code is HighBits which will be taken from the high-order bits of the address, such as AB12345678 => 171(AB)
    /// 
    /// For example:
    /// 
    /// If the destination address we found is 3890012345, its Section is 3890000000, and the relative address is 12345
    /// 
    /// The current Section table is as follows:
    /// 
    /// AddrStart　　Prot　count　　　SIDv1　　　　　SID
    /// 34E6200000　　3　　1076　　200006300　　522000600
    /// 34E7800000　　3　　1077　　200006400　　522000700
    /// 3890000000　　3　　1078　　200006500　　562000000 <-- Section of the destination address
    /// 3890200000　　3　　1079　　200006600　　562000100
    /// 3890600000　　3　　1080　　200006700　　562000200
    /// 
    /// Each Section does not exist every time, causing the total number of Sections to increase or decrease,
    /// suppose the next time you start the game, add Section 34EA200000, and its SID will change to the following
    /// use the "count or SIDv1" of the previous save and you will get the wrong Section
    /// 
    /// AddrStart　　Prot　count　　　SIDv1　　　　　SID
    /// 34E6200000　　3　　1076　　200006300　　522000600
    /// 34E7800000　　3　　1077　　200006400　　522000700
    /// 34EA200000　　3　　1078　　200006500　　522000800 <-- Suppose this Section is added when the game is started this time, using count or SIDv1 will get the wrong Section
    /// 3890000000　　3　　1079　　200006600　　562000000 <-- The actual Section of the destination address
    /// 3890200000　　3　　1080　　200006700　　562000100
    /// 3890600000　　3　　1081　　200006800　　562000200
    /// 
    /// </summary>
    public class Section
    {
        /// <summary>
        /// The program ID of the section on PS4.
        /// </summary>
        public int PID;
        /// <summary>
        /// The unique ID of the section.
        /// </summary>
        public uint SID;
        /// <summary>
        /// The unique ID of the section, v1 (before 0.9.5.5-beta)
        /// </summary>
        public uint SIDv1;
        /// <summary>
        /// The starting address of the section.
        /// </summary>
        public ulong Start;
        /// <summary>
        /// The length of the section.
        /// </summary>
        public int Length;
        /// <summary>
        /// The name of the section.
        /// </summary>
        public string Name;
        /// <summary>
        /// Whether the section is selected.
        /// </summary>
        public bool Check;
        /// <summary>
        /// The protection type of the section.
        /// </summary>
        public uint Prot;
        /// <summary>
        /// The offset value of the section.
        /// </summary>
        public ulong Offset;
        /// <summary>
        /// Whether the name of the section is a filtering target.
        /// </summary>
        public bool IsFilter;
        /// <summary>
        /// Whether the length of the section is a filtering target.
        /// </summary>
        public bool IsFilterSize;

        public override string ToString() => $"{Start:X},{(float)Length / 1024} KB,{Name},{Prot:X},{Offset:X},{IsFilter},{IsFilterSize},{Check},{PID},{SID}";
    }

    /// <summary>
    /// The purpose of SectionTool is to initialize all sections from the PS4's process and 
    /// retrieve the corresponding section based on information such as SID or memory location.
    /// </summary>
    public class SectionTool
    {
        /// <summary>
        /// This field is used to record the number of selected sections.
        /// </summary>
        public uint TotalSelected;
        /// <summary>
        /// This field is used to record the total memory size of the selected sections.
        /// </summary>
        public ulong TotalMemorySize;

        /// <summary>
        /// good pattern for using a Global Mutex in C#
        /// https://stackoverflow.com/a/229567
        /// </summary>
        private readonly MutexAccessRule allowEveryoneRule;
        private readonly MutexSecurity mSec;
        private readonly Mutex mutex;

        public SectionTool()
        {
            allowEveryoneRule = new MutexAccessRule(new SecurityIdentifier(WellKnownSidType.WorldSid, null), MutexRights.FullControl, AccessControlType.Allow);
            mSec = new MutexSecurity();
            mSec.AddAccessRule(allowEveryoneRule);
            mutex = new Mutex(false, "SectionTool", out _, mSec);
        }

        /// <summary>
        /// PS4 program ID.
        /// </summary>
        public int PID { get; private set; }
        /// <summary>
        /// The memory start address of the PS4 program.
        /// </summary>
        public ulong MemoryStart { get; private set; }
        /// <summary>
        /// The memory end address of the PS4 program.
        /// </summary>
        public ulong MemoryEnd { get; private set; }
        /// <summary>
        /// SectionDict stores all sections of the specified PS4 program.
        /// </summary>
        public Dictionary<uint, Section> SectionDict { get; private set; }
        /// <summary>
        /// SectionList stores all sections of the specified PS4 program and is sorted based on the starting address of the sections in ascending order.
        /// </summary>
        public List<(uint SID, ulong start, ulong end)> SectionList { get; private set; }


        /// <summary>
        /// MemoryEntry sorting order:
        /// 1. No name is ranked first,
        /// 2. Prot is from small to large,
        /// 3. Name is executable,
        /// 4. Start address is from small to large,
        /// 5. Finally, it is sorted by name
        /// </summary>
        private int CompareMemoryEntry(libdebug.MemoryEntry e1, libdebug.MemoryEntry e2)
        {
            int result = 0;
            if (e1.name == "" || e2.name == "") result = e1.name.CompareTo(e2.name);
            if (result != 0) return result;

            result = e1.prot.CompareTo(e2.prot);
            if (result != 0) return result;

            if (e1.name == "executable" || e2.name == "executable") result = ((e1.name == "executable" ? " " : "") + e1.name).CompareTo((e2.name == "executable" ? " " : "") + e2.name);
            if (result != 0) return result;

            result = e1.start.CompareTo(e2.start);
            if (result != 0) return result;

            result = e1.name.CompareTo(e2.name);
            return result;
        }

        /// <summary>
        /// Initialize SectionDict
        /// </summary>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSections(string processName)
        {
            libdebug.ProcessInfo processInfo = PS4Tool.GetProcessInfo(processName);

            if (processInfo.pid == 0) throw new Exception(string.Format("{0}: ProcessInfo is null.", processName));

            InitSections(processInfo.pid, processName);
        }

        /// <summary>
        /// Initialize SectionDict
        /// </summary>
        /// <param name="processID">specified process id</param>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSections(int processID, string processName)
        {
            libdebug.ProcessMap pMap = PS4Tool.GetProcessMaps(processID);

            if (pMap == null || pMap.entries == null || pMap.entries.Length == 0) throw new Exception(string.Format("{0}: Process({1}) Map is null.", processName, processID));

            InitSections(pMap, processID, processName);
        }

        /// <summary>
        /// Initialize SectionDict
        /// Retrieve all MemoryEntry objects from ProcessMap, calculate a unique ID (SID) for each, 
        /// and then generate Section objects and store them in SectionDict.
        /// </summary>
        /// <param name="pMap">libdebug.ProcessMap</param>
        /// <param name="processID">specified process id</param>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSections(libdebug.ProcessMap pMap, int processID, string processName)
        {
            if (pMap == null || pMap.entries == null || pMap.entries.Length == 0) throw new Exception(string.Format("{0}: Process({1}) Map is null.", processName, processID));

            mutex.WaitOne();
            try
            {
                string SectionFilterKeys = Properties.Settings.Default.SectionFilterKeys.Value;
                uint SectionFilterSize = Properties.Settings.Default.SectionFilterSize.Value;
                SectionFilterKeys = Regex.Replace(SectionFilterKeys, " *[,;] *", "|");
                SectionDict = new Dictionary<uint, Section>();
                SectionList = new List<(uint SID, ulong start, ulong end)>();
                TotalSelected = 0;
                TotalMemorySize = 0;
                PID = pMap.pid;
                (uint sIdx, uint ProtCnt) v1 = (0, 0);
                (uint sIdx, uint ProtCnt) v2 = (0, 0);
                (uint HighBits, uint TypeCode, uint Prot) tmp = (0, 0, 0);
                Array.Sort(pMap.entries, CompareMemoryEntry); //Sort MemoryEntry in order to calculate SID
                for (int i = 0; i < pMap.entries.Length; i++)
                {
                    libdebug.MemoryEntry entry = pMap.entries[i];
                    if ((entry.prot & 0x1) != 0x1) continue;

                    ulong start = entry.start;
                    ulong end = entry.end;
                    ulong length = end - start;
                    bool isFilter = SectionIsFilter(entry.name, SectionFilterKeys);
                    uint idx = 0;
                    uint highBits = (uint)((start & 0xffffffff00000000) >> 32); //get higher bits value, parse higher bits into lower bits
                    uint typeCode = !string.IsNullOrWhiteSpace(entry.name) ? 1u : 2u; //first code of SID, unnamed 1, named 2

                    ulong bufferLength = 1024 * 1024 * 128; //128M
                    if ((entry.prot & 0x5) == 0x5) bufferLength = length; //Executable section
                    if (MemoryStart == 0 || start < MemoryStart) MemoryStart = start;
                    if (MemoryEnd == 0 || end > MemoryEnd) MemoryEnd = end;
                    if (tmp.HighBits > 0 && tmp.HighBits != highBits) v2.sIdx = 0; //Calculate SID value: reset v2.sIdx to zero when the highVal has changed
                    if (tmp.TypeCode > 0 && tmp.TypeCode != typeCode) v2 = (0, 0); //Calculate SID value: reset v2 when the firstId has changed
                    if (tmp.Prot > 0 && tmp.Prot != entry.prot)
                    { //Calculate SID value: Increase the prot count and reset sIdx to zero when the prot has changed
                        v1 = (0, ++v1.ProtCnt);
                        v2 = (0, ++v2.ProtCnt);
                    }
                    while (length != 0)
                    {
                        ulong curLength = bufferLength;

                        if (curLength > length)
                        {
                            curLength = length;
                            length = 0;
                        }
                        else length -= curLength;

                        Section section = new Section
                        {
                            PID = pMap.pid,
                            SIDv1 = idx + v1.sIdx * 100 + v1.ProtCnt * 1000000 + typeCode * 100000000,
                            SID = idx + v2.sIdx * 100 + v2.ProtCnt * 100000 + typeCode * 1000000 + highBits * 10000000,
                            Start = start,
                            Length = (int)curLength,
                            Name = entry.name + "[" + idx + "]",
                            Check = false,
                            Prot = entry.prot,
                            Offset = entry.offset
                        };
                        if (isFilter) section.IsFilter = true;
                        else if (section.Length < SectionFilterSize) section.IsFilterSize = true;

                        SectionDict.Add(section.SID, section);

                        start += curLength;
                        idx++;
                    }
                    if (idx > 99)
                    {
                        v1.sIdx += idx / 100;
                        v2.sIdx += idx / 100;
                    }
                    v1.sIdx++;
                    if (++v2.sIdx > 999) //v2.sIdx++;
                    {
                        v2.ProtCnt++;
                        v2.sIdx = 0;
                    }
                    tmp = (highBits, typeCode, entry.prot);
                }
            }
            catch (Exception) { throw; }
            finally { mutex.ReleaseMutex(); }
        }

        /// <summary>
        /// Add sections to the SectionList sequentially and sort them
        /// based on the starting address of the sections in ascending order.
        /// </summary>
        public void InitSectionList()
        {
            if (SectionDict == null || SectionDict.Count == 0) return;

            mutex.WaitOne();
            try
            {
                List<uint> keys = new List<uint>(SectionDict.Keys);
                SectionList = new List<(uint SID, ulong start, ulong end)>();
                for (int idx = 0; idx < keys.Count; idx++)
                {
                    Section section = SectionDict[keys[idx]];
                    SectionList.Add((section.SID, section.Start, section.Start + (ulong)section.Length));
                }
                SectionList.Sort((s1, s2) => s1.start.CompareTo(s2.start));
            }
            catch (Exception) { throw; }
            finally { mutex.ReleaseMutex(); }
        }

        /// <summary>
        /// Check if section needs to be filtered
        /// </summary>
        /// <param name="name">specified section name</param>
        /// <param name="sectionFilterKeys">filters for Section in regex</param>
        /// <returns></returns>
        public bool SectionIsFilter(string name, string sectionFilterKeys)
        {
            bool result = false;
            if (Regex.IsMatch(name, sectionFilterKeys)) result = true;

            return result;
        }

        /// <summary>
        /// find Section with name, prot as unique keys
        /// </summary>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns></returns>
        public Section GetSection(string name, uint prot)
        {
            Section section = null;

            List<uint> keys = new List<uint>(SectionDict.Keys);
            keys.Sort();
            for (int idx = 0; idx < keys.Count; idx++)
            {
                section = SectionDict[keys[idx]];
                if ((section.Name == name || section.Name == name + "[0]") && section.Prot == prot) break;
            }
            return section;
        }

        /// <summary>
        /// find Section with sid as unique keys
        /// </summary>
        /// <param name="sid"></param>
        /// <returns></returns>
        public Section GetSection(uint sid)
        {
            if (SectionDict == null) return null;

            SectionDict.TryGetValue(sid, out Section section);

            return section;
        }

        /// <summary>
        /// find Section with sid, name, prot as unique keys
        /// </summary>
        /// <param name="sid"></param>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns></returns>
        public Section GetSection(uint sid, string name, uint prot)
        {
            Section section = GetSection(sid);
            if (section != null && name != null && name.Length > 0 && (!name.Contains(section.Name) || prot != section.Prot)) section = GetSection(name, prot);

            return section;
        }

        /// find Section with SIDv1, name, prot as unique keys
        /// </summary>
        /// <param name="SIDv1">SID, v1 (before 0.9.5.5-beta)</param>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns>Section</returns>
        public Section GetSectionBySIDv1(uint SIDv1, string name, uint prot)
        {
            List<uint> keys = new List<uint>(SectionDict.Keys);
            for (int sectionIdx = 0; sectionIdx < keys.Count; sectionIdx++)
            {
                Section section = SectionDict[keys[sectionIdx]];
                if (section.SIDv1 == SIDv1)
                {
                    if (name != null && name.Length > 0 && !name.Contains(section.Name)) section = GetSection(name, prot);
                    return section;
                }
            }

            return null;
        }

        /// <summary>
        /// get its section SID by address
        /// </summary>
        /// <param name="address">query address</param>
        /// <returns>section SID</returns>
        public uint GetSectionID(ulong address)
        {
            if (MemoryStart > address || MemoryEnd < address) return 0; //-1(int) => 0(uint)

            if (SectionList == null || SectionList.Count == 0) InitSectionList();

            int low = 0;
            int high = SectionList.Count - 1;
            int middle;

            while (low <= high)
            {
                middle = (low + high) / 2;
                (uint SID, ulong start, ulong end) = SectionList[middle];
                if (address >= end) low = middle + 1;   //find the second half of the array
                else if (address < start) high = middle - 1;  //find the first half of the array
                else return SID;  //return SID of the specified address
            }

            return 0;
        }


        /// <summary>
        /// get Sections sorted by address
        /// </summary>
        /// <param name="collection">get only Sections of the specified SID, is optional</param>
        /// <returns>section array</returns>
        public Section[] GetSectionSortByAddr(IEnumerable<uint> collection = null)
        {
            if (collection == null) collection = SectionDict.Keys;
            List<uint> keys = new List<uint>(collection);
            Section[] sections = new Section[keys.Count];
            for (int sectionIdx = 0; sectionIdx < keys.Count; sectionIdx++) sections[sectionIdx] = SectionDict[keys[sectionIdx]];
            Array.Sort(sections, CompareSection);

            return sections;
        }

        /// <summary>
        /// get Sections sorted by address and return the position of the given SID
        /// </summary>
        /// <param name="SID">find the position of the SID</param>
        /// <param name="idx">position index of the SID</param>
        /// <param name="collection">get only Sections of the specified SID, is optional</param>
        /// <returns>section array</returns>
        public Section[] GetSectionSortByAddr(uint SID, out int idx, IEnumerable<uint> collection = null)
        {
            idx = -1;
            Section[] sections = GetSectionSortByAddr(collection);

            for (int sectionIdx = 0; sectionIdx < sections.Length; sectionIdx++)
            {
                Section section = sections[sectionIdx];
                if (section.SID != SID) continue;
                idx = sectionIdx;
                break;
            }

            return sections;
        }

        /// <summary>
        /// sort Sections by start address
        /// </summary>
        public int CompareSection(Section s1, Section s2) => s1.Start.CompareTo(s2.Start);
        
        /// <summary>
        /// sort Sections by SID
        /// </summary>
        public int CompareSectionSID(Section s1, Section s2) => s1.SID.CompareTo(s2.SID);
    }
}
