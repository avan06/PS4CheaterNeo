using libdebug;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Threading;

namespace PS4CheaterNeo
{
    public class SectionTool
    {
        private readonly Mutex mutex = new Mutex();
        public ulong TotalMemorySize;
        public int PID { get; private set; }
        public ulong MemoryStart { get; private set; }
        public ulong MemoryEnd { get; private set; }
        public Dictionary<uint, Section> SectionDict { get; private set; }
        public List<(uint SID, ulong start, ulong end)> SectionList { get; private set; }
        /// <summary>
        /// [About SID]
        /// To process memory addresses, the program needs to use SectionID to obtain the corresponding Section.
        /// 
        /// The original PS4_Cheater's rule for establishing SectionID is to sort Sections from low to high address, and obtain the count value as SectionsID.
        /// for example, if the SectionID is 100, the Section in the 100th position will be read.
        /// 
        /// What is the problem? When the number of Sections is low, the order will not be wrong,
        /// but if the number of Sections is from one hundred to more than one thousand, it is easy to obtain the wrong Section,
        /// because the game is started at different times, the value of Section often changes.
        /// 
        ///
        /// This program attempts to create a SectionID that can correctly correspond to a Section at different times,
        /// SectionID is abbreviated as SID below, and its encoding rules are as follows(rules established before 0.9.5.5-beta):
        /// 
        /// 1. The 1st code is idx used to count multiple Sections generated by the same MemoryEntry
        /// 2. The 3rd to 6th code is sIdx will continue to count until the Prot value changes and will be reset
        /// 3. The 7th to 8th code is ProtCnt will count when the Prot value changes
        /// 4. The 9th code is the TypeCode when the Section has a name it is 1, otherwise it is 2
        /// 
        /// 
        /// After a while, I found that the above rules are still not enough,
        /// and the new encoding rules from the 0.9.5.5-beta are as follows:
        /// 
        /// 1. The 1st code is idx used to count multiple Sections generated by the same MemoryEntry
        /// 2. The 3rd to 5th code is sIdx will continue to count until the HighBits or TypeCode or Prot changes, it will be reset
        /// 3. The 6th code is ProtCnt which counts when the Prot value changes and resets when the TypeCode changes
        /// 4. The 7th code is the TypeCode when the Section has a name it is 1, otherwise it is 2
        /// 5. The 8th to 10th code is HighBits which will be taken from the high-order bits of the address, such as AB12345678 => 171(AB)
        /// 
        /// For example:
        /// 
        /// If the destination address we found is 3890012345, its Section is 3890000000, and the relative address is 12345
        /// 
        /// The current Section table is as follows:
        /// 
        /// AddrStart　　Prot　count　　　SIDv1　　　　　SID
        /// 34E6200000　　3　　1076　　200006300　　522000600
        /// 34E7800000　　3　　1077　　200006400　　522000700
        /// 3890000000　　3　　1078　　200006500　　562000000 <-- Section of the destination address
        /// 3890200000　　3　　1079　　200006600　　562000100
        /// 3890600000　　3　　1080　　200006700　　562000200
        /// 
        /// Each Section does not exist every time, causing the total number of Sections to increase or decrease,
        /// suppose the next time you start the game, add Section 34EA200000, and its SID will change to the following
        /// use the "count or SIDv1" of the previous save and you will get the wrong Section
        /// 
        /// AddrStart　　Prot　count　　　SIDv1　　　　　SID
        /// 34E6200000　　3　　1076　　200006300　　522000600
        /// 34E7800000　　3　　1077　　200006400　　522000700
        /// 34EA200000　　3　　1078　　200006500　　522000800 <-- Suppose this Section is added when the game is started this time, using count or SIDv1 will get the wrong Section
        /// 3890000000　　3　　1079　　200006600　　562000000 <-- The actual Section of the destination address
        /// 3890200000　　3　　1080　　200006700　　562000100
        /// 3890600000　　3　　1081　　200006800　　562000200
        /// 
        /// </summary>
        public class Section
        {
            public int PID;
            public uint SID;
            public uint SIDv1; //SID, v1 (before 0.9.5.5-beta)
            public ulong Start;
            public int Length;
            public string Name;
            public bool Check;
            public uint Prot;
            public ulong Offset;
            public bool IsFilter;
            public bool IsFilterSize;

            public override string ToString() => $"{Start:X},{(float)Length / 1024} KB,{Name},{Prot:X},{Offset:X},{IsFilter},{IsFilterSize},{Check},{PID},{SID}";
        }

        /// <summary>
        /// MemoryEntry sorting order:
        /// 1. No name is ranked first,
        /// 2. Prot is from small to large,
        /// 3. Name is executable,
        /// 4. Start address is from small to large,
        /// 5. Finally, it is sorted by name
        /// </summary>
        private int CompareMemoryEntry(MemoryEntry e1, MemoryEntry e2)
        {
            int result = 0;
            if (e1.name == "" || e2.name == "") result = e1.name.CompareTo(e2.name);
            if (result != 0) return result;

            result = e1.prot.CompareTo(e2.prot);
            if (result != 0) return result;

            if (e1.name == "executable" || e2.name == "executable") result = ((e1.name == "executable" ? " " : "") + e1.name).CompareTo((e2.name == "executable" ? " " : "") + e2.name);
            if (result != 0) return result;

            result = e1.start.CompareTo(e2.start);
            if (result != 0) return result;

            result = e1.name.CompareTo(e2.name);
            return result;
        }

        /// <summary>
        /// Initialize section list
        /// </summary>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSectionList(string processName)
        {
            ProcessInfo processInfo = PS4Tool.GetProcessInfo(processName);

            if (processInfo.pid == 0) throw new Exception(string.Format("{0}: ProcessInfo is null.", processName));

            InitSectionList(processInfo.pid, processName);
        }

        /// <summary>
        /// Initialize section list
        /// </summary>
        /// <param name="processID">specified process id</param>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSectionList(int processID, string processName)
        {
            ProcessMap pMap = PS4Tool.GetProcessMaps(processID);

            if (pMap == null || pMap.entries == null || pMap.entries.Length == 0) throw new Exception(string.Format("{0}: Process({1}) Map is null.", processName, processID));

            InitSectionList(pMap, processID, processName);
        }

        /// <summary>
        /// Initialize section list
        /// </summary>
        /// <param name="pMap">libdebug.ProcessMap</param>
        /// <param name="processID">specified process id</param>
        /// <param name="processName">specified process name</param>
        /// <exception cref="Exception"></exception>
        public void InitSectionList(ProcessMap pMap, int processID, string processName)
        {
            if (pMap == null || pMap.entries == null || pMap.entries.Length == 0) throw new Exception(string.Format("{0}: Process({1}) Map is null.", processName, processID));

            mutex.WaitOne();
            try
            {
                string SectionFilterKeys = Properties.Settings.Default.SectionFilterKeys.Value;
                uint SectionFilterSize = Properties.Settings.Default.SectionFilterSize.Value;
                SectionFilterKeys = Regex.Replace(SectionFilterKeys, " *[,;] *", "|");
                SectionDict = new Dictionary<uint, Section>();
                SectionList = new List<(uint SID, ulong start, ulong end)>();
                TotalMemorySize = 0;
                PID = pMap.pid;
                (uint sIdx, uint ProtCnt) v1 = (0, 0);
                (uint sIdx, uint ProtCnt) v2 = (0, 0);
                (uint HighBits, uint TypeCode, uint Prot) tmp = (0, 0, 0);
                Array.Sort(pMap.entries, CompareMemoryEntry); //Sort MemoryEntry in order to calculate SID
                for (int i = 0; i < pMap.entries.Length; i++)
                {
                    MemoryEntry entry = pMap.entries[i];
                    if ((entry.prot & 0x1) != 0x1) continue;

                    ulong start = entry.start;
                    ulong end = entry.end;
                    ulong length = end - start;
                    bool isFilter = SectionIsFilter(entry.name, SectionFilterKeys);
                    uint idx = 0;
                    uint highBits = (uint)((start & 0xffffffff00000000) >> 32); //get higher bits value, parse higher bits into lower bits
                    uint typeCode = !string.IsNullOrWhiteSpace(entry.name) ? 1u : 2u; //first code of SID, unnamed 1, named 2

                    ulong bufferLength = 1024 * 1024 * 128; //128M
                    if ((entry.prot & 0x5) == 0x5) bufferLength = length; //Executable section
                    if (MemoryStart == 0 || start < MemoryStart) MemoryStart = start;
                    if (MemoryEnd == 0 || end > MemoryEnd) MemoryEnd = end;
                    if (tmp.HighBits > 0 && tmp.HighBits != highBits) v2.sIdx = 0; //Calculate SID value: reset v2.sIdx to zero when the highVal has changed
                    if (tmp.TypeCode > 0 && tmp.TypeCode != typeCode) v2 = (0, 0); //Calculate SID value: reset v2 when the firstId has changed
                    if (tmp.Prot > 0 && tmp.Prot != entry.prot)
                    { //Calculate SID value: Increase the prot count and reset sIdx to zero when the prot has changed
                        v1 = (0, ++v1.ProtCnt);
                        v2 = (0, ++v2.ProtCnt);
                    }
                    while (length != 0)
                    {
                        ulong curLength = bufferLength;

                        if (curLength > length)
                        {
                            curLength = length;
                            length = 0;
                        }
                        else length -= curLength;

                        Section section = new Section();
                        section.PID = pMap.pid;
                        section.SID = highBits * 10000000 + typeCode * 1000000 + v2.ProtCnt * 100000 + v2.sIdx * 100 + idx;
                        section.SIDv1 = typeCode * 100000000 + v1.ProtCnt * 1000000 + v1.sIdx * 100 + idx;
                        section.Start = start;
                        section.Length = (int)curLength;
                        section.Name = entry.name + "[" + idx + "]";
                        section.Check = false;
                        section.Prot = entry.prot;
                        section.Offset = entry.offset;
                        if (isFilter) section.IsFilter = true;
                        else if (section.Length < SectionFilterSize) section.IsFilterSize = true;

                        SectionDict.Add(section.SID, section);
                        SectionList.Add((section.SID, start, start + curLength));

                        start += curLength;
                        idx++;
                    }
                    if (idx > 99)
                    {
                        v1.sIdx += idx / 100;
                        v2.sIdx += idx / 100;
                    }
                    v1.sIdx++;
                    v2.sIdx++;
                    tmp = (highBits, typeCode, entry.prot);
                }
                SectionList.Sort((s1, s2) => s1.start.CompareTo(s2.start));
                mutex.ReleaseMutex();
            }
            catch (Exception)
            {
                mutex.ReleaseMutex();
                throw;
            }
        }

        /// <summary>
        /// Check if section needs to be filtered
        /// </summary>
        /// <param name="name">specified section name</param>
        /// <param name="sectionFilterKeys">filters for Section in regex</param>
        /// <returns></returns>
        public bool SectionIsFilter(string name, string sectionFilterKeys)
        {
            bool result = false;
            if (Regex.IsMatch(name, sectionFilterKeys)) result = true;

            return result;
        }

        /// <summary>
        /// find Section with name, prot as unique keys
        /// </summary>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns></returns>
        public Section GetSection(string name, uint prot)
        {
            Section section = null;

            List<uint> keys = new List<uint>(SectionDict.Keys);
            keys.Sort();
            for (int idx = 0; idx < keys.Count; idx++)
            {
                section = SectionDict[keys[idx]];
                if ((section.Name == name || section.Name == name + "[0]") && section.Prot == prot) break;
            }
            return section;
        }

        /// <summary>
        /// find Section with sid as unique keys
        /// </summary>
        /// <param name="sid"></param>
        /// <returns></returns>
        public Section GetSection(uint sid)
        {
            if (SectionDict == null) return null;

            SectionDict.TryGetValue(sid, out Section section);

            return section;
        }

        /// <summary>
        /// find Section with sid, name, prot as unique keys
        /// </summary>
        /// <param name="sid"></param>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns></returns>
        public Section GetSection(uint sid, string name, uint prot)
        {
            Section section = GetSection(sid);
            if (section != null && name != null && name.Length > 0 && (!name.Contains(section.Name) || prot != section.Prot)) section = GetSection(name, prot);

            return section;
        }

        /// find Section with SIDv1, name, prot as unique keys
        /// </summary>
        /// <param name="SIDv1">SID, v1 (before 0.9.5.5-beta)</param>
        /// <param name="name"></param>
        /// <param name="prot"></param>
        /// <returns>Section</returns>
        public Section GetSectionBySIDv1(uint SIDv1, string name, uint prot)
        {
            List<uint> keys = new List<uint>(SectionDict.Keys);
            for (int sectionIdx = 0; sectionIdx < keys.Count; sectionIdx++)
            {
                Section section = SectionDict[keys[sectionIdx]];
                if (section.SIDv1 == SIDv1)
                {
                    if (name != null && name.Length > 0 && !name.Contains(section.Name)) section = GetSection(name, prot);
                    return section;
                }
            }

            return null;
        }

        /// <summary>
        /// get its section SID by address
        /// </summary>
        /// <param name="address">query address</param>
        /// <returns>section SID</returns>
        public uint GetSectionID(ulong address)
        {
            if (MemoryStart > address || MemoryEnd < address) return 0; //-1(int) => 0(uint)

            int low = 0;
            int high = SectionList.Count - 1;
            int middle;

            while (low <= high)
            {
                middle = (low + high) / 2;
                (uint SID, ulong start, ulong end) = SectionList[middle];
                if (address >= end) low = middle + 1;   //find the second half of the array
                else if (address < start) high = middle - 1;  //find the first half of the array
                else return SID;  //return SID of the specified address
            }

            return 0;
        }


        /// <summary>
        /// get Sections sorted by address
        /// </summary>
        /// <param name="collection">get only Sections of the specified SID, is optional</param>
        /// <returns>section array</returns>
        public Section[] GetSectionSortByAddr(IEnumerable<uint> collection = null)
        {
            if (collection == null) collection = SectionDict.Keys;
            List<uint> keys = new List<uint>(collection);
            Section[] sections = new Section[keys.Count];
            for (int sectionIdx = 0; sectionIdx < keys.Count; sectionIdx++) sections[sectionIdx] = SectionDict[keys[sectionIdx]];
            Array.Sort(sections, CompareSection);

            return sections;
        }

        /// <summary>
        /// get Sections sorted by address and return the position of the given SID
        /// </summary>
        /// <param name="SID">find the position of the SID</param>
        /// <param name="idx">position index of the SID</param>
        /// <param name="collection">get only Sections of the specified SID, is optional</param>
        /// <returns>section array</returns>
        public Section[] GetSectionSortByAddr(uint SID, out int idx, IEnumerable<uint> collection = null)
        {
            idx = -1;
            Section[] sections = GetSectionSortByAddr(collection);

            for (int sectionIdx = 0; sectionIdx < sections.Length; sectionIdx++)
            {
                Section section = sections[sectionIdx];
                if (section.SID != SID) continue;
                idx = sectionIdx;
                break;
            }

            return sections;
        }

        /// <summary>
        /// sort Sections by start address
        /// </summary>
        public int CompareSection(Section s1, Section s2) => s1.Start.CompareTo(s2.Start);
        
        /// <summary>
        /// sort Sections by SID
        /// </summary>
        public int CompareSectionSID(Section s1, Section s2) => s1.SID.CompareTo(s2.SID);
    }
}
